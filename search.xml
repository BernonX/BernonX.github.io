<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git分布式版本控制工具</title>
      <link href="/2026/01/29/2026-1-29-Git/"/>
      <url>/2026/01/29/2026-1-29-Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git入门"><a href="#Git入门" class="headerlink" title="Git入门"></a>Git入门</h1><p><strong>Git</strong> 是一个免费且开源的分布式版本控制系统设计用于处理从小型到非常大型且高效且快速的项目。</p><h2 id="关于版本控制"><a href="#关于版本控制" class="headerlink" title="关于版本控制"></a>关于版本控制</h2><p>什么是“版本控制”？我为什么要关心它呢？</p><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 在本文所展示的例子中，我们对保存着软件源代码的文件作版本控制，但实际上，你可以对<strong>任何类型</strong>的文件进行版本控制。</p><p>如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能），采用版本控制系统（VCS）是个明智的选择。 有了它你就可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。 使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。</p><h3 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h3>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础篇</title>
      <link href="/2026/01/24/2026-1-24-RedisBasic/"/>
      <url>/2026/01/24/2026-1-24-RedisBasic/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding simple"><i class="note-icon fab fa-bilibili"></i><p>本文章改编自黑马程序员课程：<a href="https://www.bilibili.com/video/BV1cr4y1671t" title="点击跳转">Redis入门到实战</a></p></div><h1 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h1><p>Redis是一种键值型的NoSql数据库，这里有两个关键字：</p><ul><li><p>键值型</p></li><li><p>NoSql</p></li></ul><p>其中<strong>键值型</strong>，是指Redis中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至Json；</p><p>而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。</p><h2 id="认识NoSQL"><a href="#认识NoSQL" class="headerlink" title="认识NoSQL"></a>认识NoSQL</h2><p><strong>NoSql</strong> 可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<strong>非关系型数据库</strong>。</p><h3 id="结构化与非结构化"><a href="#结构化与非结构化" class="headerlink" title="结构化与非结构化"></a>结构化与非结构化</h3><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名、字段数据类型、字段约束等等信息，插入的数据必须遵守这些约束</p><p>而 NoSql 则对数据库格式没有严格约束，往往形式松散，自由。可以是键值型，也可以是文档型，甚至可以是图格式。</p><h3 id="关联和非关联"><a href="#关联和非关联" class="headerlink" title="关联和非关联"></a>关联和非关联</h3><p>传统数据库的表与表之间往往存在关联，例如外键</p><p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  name<span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  orders<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        title<span class="punctuation">:</span> <span class="string">&quot;小米12s pro&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">4999</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此处要维护“张三”的订单与商品的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。</p><h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, age <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis</span></span><br><span class="line">get user:1</span><br><span class="line"><span class="comment"># MongoDB</span></span><br><span class="line">db.users.find(&#123;_id: 1&#125;)</span><br><span class="line"><span class="comment">#elasticsearch</span></span><br><span class="line">GET http://localhost:9200/users/1</span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>传统关系型数据库能满足事务ACID的原则：</p><div class="table-container"><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:left">核心定义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Atomicity<br>（原子性）</strong></td><td style="text-align:left">事务是一个不可分割的最小执行单元，要么全部执行成功，要么全部执行失败回滚（Rollback）</td></tr><tr><td style="text-align:center"><strong>Consistency<br>（一致性）</strong></td><td style="text-align:left">事务执行前后，数据库的完整性约束不被破坏，数据从一个合法状态转换到另一个合法状态</td></tr><tr><td style="text-align:center"><strong>Isolation<br>（隔离性）</strong></td><td style="text-align:left">多个并发执行的事务之间相互独立，一个事务的执行不会被其他事务干扰，每个事务都感觉不到其他事务的存在。</td></tr><tr><td style="text-align:center"><strong>Durability<br>（持久性）</strong></td><td style="text-align:left">事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失</td></tr></tbody></table></div><p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>除了上述四点以外，在存储方式、扩展性、查询性能上关系型与非关系型也都有着显著差异，总结如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">SQL</th><th style="text-align:center">NoSQL</th></tr></thead><tbody><tr><td style="text-align:center">数据结构</td><td style="text-align:center">结构化（Structured）</td><td style="text-align:center">非结构化</td></tr><tr><td style="text-align:center">数据关联</td><td style="text-align:center">关联的（Relational）</td><td style="text-align:center">无关联的</td></tr><tr><td style="text-align:center">查询方式</td><td style="text-align:center">SQL查询</td><td style="text-align:center">非SQL</td></tr><tr><td style="text-align:center">事务特性</td><td style="text-align:center">ACID</td><td style="text-align:center">BASE</td></tr><tr><td style="text-align:center">存储方式</td><td style="text-align:center">磁盘</td><td style="text-align:center">内存</td></tr><tr><td style="text-align:center">扩展性</td><td style="text-align:center">垂直</td><td style="text-align:center">水平</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">1）数据结构固定<br>2）相关业务对数据安全性、一致性要求较高</td><td style="text-align:center">1）数据结构不固定<br>2）对一致性、安全性要求不高<br>3）对性能要求高</td></tr></tbody></table></div><h2 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a>认识Redis</h2><p>Redis诞生于2009年，全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p><strong>特征</strong>：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><p><strong>作者</strong>：Antirez</p><p>Redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></p><h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><h3 id="Windows安装Redis"><a href="#Windows安装Redis" class="headerlink" title="Windows安装Redis"></a>Windows安装Redis</h3><div class="note blue no-icon flat"><p>下载链接</p><ul><li><a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></li><li><a href="https://github.com/MicrosoftArchive/redis/releases">https://github.com/MicrosoftArchive/redis/releases</a></li></ul></div><ol><li><p>下载 <code>.zip</code> 压缩包，将下载的压缩包解压到指定的文件夹中，如：<code>D:\Redis</code></p></li><li><p>在 Redis 的安装目录下打开cmd窗口，然后执行命令来启动服务</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br><span class="line"><span class="comment">#命令里面的 redis.windows.conf 可以省略，省略后，使用 redis-server.exe 命令会使用默认的配置。</span></span><br></pre></td></tr></table></figure><p> 为了方便，建议把 Redis 路径配置到系统变量 Path 值中，这样就省得再输路径了</p></li><li><p>打开 Redis 客户端进行连接</p><ul><li><p>我们使用 <code>redis-cli.exe</code> 命令来打开 Redis 客户端</p></li><li><p>在命令中输入<code>ping</code>与 Redis 服务端做心跳测试，服务端正常会返回<code>PONG</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\Redis&gt;redis-cli.exe</span><br><span class="line">127.0.0.1:6379&gt;ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="Linux安装Redis"><a href="#Linux安装Redis" class="headerlink" title="Linux安装Redis"></a>Linux安装Redis</h3><div class="note blue no-icon flat"><p>官网下载（所有版本都有）：<a href="https://download.redis.io/releases/">https://download.redis.io/releases/</a></p></div><ol><li><p>在官网下载Linux压缩文件并上传到虚拟机的任意目录</p></li><li><p>解压缩，注意版本换成下载的版本号</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf redis-x.x.x.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>依赖库</p><ul><li><p>Redis 是基于 C 语言编写的，因此首先需要安装 Redis 所需要的 gcc 依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure></li></ul></li><li><p>进入Redis目录并运行编译命令</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-x.x.x</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><ul><li>如果没有出错，应该就安装成功了</li><li>默认的安装路径是在 <code>/usr/local/bin</code> 目录下</li><li>该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：<ul><li><code>redis-cli</code>：是 Redis 提供的命令行客户端</li><li><code>redis-server</code>：是 Redis 的服务端启动脚本</li><li><code>redis-sentinel</code>：是 Redis 的哨兵启动脚本</li></ul></li></ul></li></ol><h3 id="启动、停止服务"><a href="#启动、停止服务" class="headerlink" title="启动、停止服务"></a>启动、停止服务</h3><ul><li><p>安装完成后，在任意目录输入<code>redis-server</code>命令即可启动 Redis</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure></li><li><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<kbd>CTRL</kbd>+<kbd>C</kbd>则 Redis 停止。不推荐使用。</p></li><li><p>如果要让 Redis 以<code>后台</code>方式启动，则必须修改 Redis 配置文件，就在我们之前解压的 Redis 安装包下（<code>/usr/local/src/redis-x.x.x</code>），名字叫 redis.conf</p></li><li><p>我们修改<code>redis.conf</code>文件中的一些配置</p>  <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123456</span></span><br></pre></td></tr></table></figure></li><li><p>启动 Redis：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 Redis 安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-x.x.x</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure></li><li><p>停止服务：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用 redis-cli 来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123456 shutdown</span><br></pre></td></tr></table></figure></li></ul><h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><ul><li><p>我们也可以通过配置来实现开机自启。</p></li><li><p>首先，新建一个系统服务文件：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure></li><li><p>内容如下（记得改版本号）：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-x.x.x/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li><li><p>然后重载系统服务：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure></li><li><p>现在，我们可以用下面这组命令来操作 Redis 了</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure></li><li><p>执行下面的命令，可以让 Redis 开机自启</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure></li></ul><h2 id="Redis桌面客户端"><a href="#Redis桌面客户端" class="headerlink" title="Redis桌面客户端"></a>Redis桌面客户端</h2><p>安装完成Redis，我们就可以操作Redis，实现数据的<strong>CRUD</strong>(Create, Read, Update, Delete)了。这需要用到Redis客户端，包括：</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编程客户端</li></ul><h3 id="Redis命令行客户端"><a href="#Redis命令行客户端" class="headerlink" title="Redis命令行客户端"></a>Redis命令行客户端</h3><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123456</code>：指定redis的访问密码 </li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><h3 id="图形化桌面客户端"><a href="#图形化桌面客户端" class="headerlink" title="图形化桌面客户端"></a>图形化桌面客户端</h3><p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：<a href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a></p><p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</p><p>在下面这个仓库可以找到安装包：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>Redis默认有16个仓库，编号从0至15.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p><p>如果是基于<code>redis-cli</code>连接Redis服务，可以通过select命令来选择数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择 0 号库</span></span><br><span class="line"><span class="keyword">select</span> 0</span><br></pre></td></tr></table></figure><h1 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a>Redis常见命令</h1><p>Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：</p><ul><li><strong>String</strong>（字符串），<strong>Hash</strong>（哈希），<strong>List</strong>（列表），<strong>Set</strong>（集合）及<strong>Zset</strong>(SortedSet：有序集合)</li></ul><p>Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ <a href="https://redis.io/commands">https://redis.io/commands </a>）可以查看到不同的命令：</p><p>不同类型的命令称为一个group，我们也可以通过<code>help</code>命令来查看各种不同group的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span></span><br><span class="line">redis-cli 5.0.14.1</span><br><span class="line">To get <span class="built_in">help</span> about Redis commands <span class="built_in">type</span>:</span><br><span class="line">      <span class="string">&quot;help @&lt;group&gt;&quot;</span> to get a list of commands <span class="keyword">in</span> &lt;group&gt;</span><br><span class="line">      <span class="string">&quot;help &lt;command&gt;&quot;</span> <span class="keyword">for</span> <span class="built_in">help</span> on &lt;<span class="built_in">command</span>&gt;</span><br><span class="line">      <span class="string">&quot;help &lt;tab&gt;&quot;</span> to get a list of possible <span class="built_in">help</span> topics</span><br><span class="line">      <span class="string">&quot;quit&quot;</span> to <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">To <span class="built_in">set</span> redis-cli preferences:</span><br><span class="line">      <span class="string">&quot;:set hints&quot;</span> <span class="built_in">enable</span> online hints</span><br><span class="line">      <span class="string">&quot;:set nohints&quot;</span> <span class="built_in">disable</span> online hints</span><br><span class="line">Set your preferences <span class="keyword">in</span> ~/.redisclirc</span><br></pre></td></tr></table></figure><p>接下来，我们就学习常见的五种基本数据类型的相关命令。</p><h2 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li><strong>KEYS</strong>：查看符合模板的所有key</li><li><strong>DEL</strong>：删除一个指定的key</li><li><strong>EXISTS</strong>：判断key是否存在</li><li><strong>EXPIRE</strong>：给一个key设置有效期，有效期到期时该key会被自动删除</li><li><strong>TTL</strong>：查看一个KEY的剩余有效期</li></ul><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li><strong>string</strong>：普通字符串</li><li><strong>int</strong>：整数类型，可以做自增、自减操作</li><li><strong>float</strong>：浮点类型，可以做自增、自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512M</p><h3 id="String的常见命令"><a href="#String的常见命令" class="headerlink" title="String的常见命令"></a>String的常见命令</h3><p>String的常见命令有：</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">SET</td><td style="text-align:center">添加或者修改已经存在的一个String类型的键值对</td></tr><tr><td style="text-align:center">GET</td><td style="text-align:center">根据key获取String类型的value</td></tr><tr><td style="text-align:center">MSET</td><td style="text-align:center">批量添加多个String类型的键值对</td></tr><tr><td style="text-align:center">MGET</td><td style="text-align:center">根据多个key获取多个String类型的value</td></tr><tr><td style="text-align:center">INCR</td><td style="text-align:center">让一个整型的key自增1</td></tr><tr><td style="text-align:center">INCRBY</td><td style="text-align:center">让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</td></tr><tr><td style="text-align:center">INCRBYFLOAT</td><td style="text-align:center">让一个浮点类型的数字自增并指定步长</td></tr><tr><td style="text-align:center">SETNX</td><td style="text-align:center">添加一个String类型的键值对，前提是这个key不存在，否则不执行</td></tr><tr><td style="text-align:center">SETEX</td><td style="text-align:center">添加一个String类型的键值对，并且指定有效期</td></tr></tbody></table></div><h3 id="Key结构"><a href="#Key结构" class="headerlink" title="Key结构"></a>Key结构</h3><p>Redis 没有类似 MySQL 中的 Table 的概念，我们该如何区分不同类型的 key 呢？</p><p>例如，需要存储用户、商品信息到 redis，有一个用户 id 是1，有一个商品 id 恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给 key 添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p><p>Redis 的 key 允许有多个单词形成层级结构，多个单词之间用 <code>:</code> 隔开，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。这样以来，我们就可以把不同类型的数据区分开了。从而避免了 key 的冲突问题。</p><p>例如我们的项目名称叫 heima，有<code>user</code>和<code>product</code>两种不同类型的数据，我们可以这样定义key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># user 相关的 key</span><br><span class="line">heima:user:1</span><br><span class="line"># product 相关的 key</span><br><span class="line">heima:product:1</span><br></pre></td></tr></table></figure><p>如果 Value 是一个 Java 对象，例如一个 User 对象，则可以将对象序列化为 JSON 字符串后存储：</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>KEY</strong></th><th style="text-align:center"><strong>VALUE</strong></th></tr></thead><tbody><tr><td style="text-align:center">heima:user:1</td><td style="text-align:center">{“id”:1,  “name”: “Jack”, “age”: 21}</td></tr><tr><td style="text-align:center">heima:product:1</td><td style="text-align:center">{“id”:1,  “name”: “Xiaomi 12”, “price”: 4999}</td></tr></tbody></table></div><p>并且，在 Redis 的桌面客户端中，还会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰</p><h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><p>Hash类型，也叫散列，其 value 是一个无序字典，类似于 Java 中的 HashMap 结构。</p><p>String 结构是将对象序列化为 JSON 字符串后存储，当需要修改对象某个字段时很不方便</p><p>Hash 结构可以将对象中的每个字段独立存储，可以针对单个字段做 CRUD：</p><table>  <tbody>    <tr style="text-align:center">      <td rowspan="2" bgcolor="#d3e0e9">KEY</td>      <td colspan="2" bgcolor="#d3e0e9">VALUE</td>    </tr>    <tr style="text-align:center">      <td bgcolor="#eaeef7">field</td>      <td bgcolor="#eaeef7">value</td>    </tr>    <tr style="text-align:center">      <td rowspan="2">reggie:user:1</td>      <td>name</td>      <td>Jack</td>    </tr>    <tr style="text-align:center">      <td>age&nbsp;</td>      <td>21</td>    </tr>    <tr style="text-align:center">      <td rowspan="2"><br>reggie:user:2</td>      <td>name&nbsp;</td>      <td>Rose</td>    </tr>    <tr style="text-align:center">      <td>age&nbsp;</td>      <td>18</td>    </tr>  </tbody>  <colgroup>    <col>    <col>    <col>  </colgroup></table><p>Hash的常见命令有：</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">HSET key field value</td><td style="text-align:center">添加或者修改 hash 类型 key 的 field 的值</td></tr><tr><td style="text-align:center">HGET key field</td><td style="text-align:center">获取一个 hash 类型 key 的 field 的值</td></tr><tr><td style="text-align:center">HMSET</td><td style="text-align:center">批量添加多个 hash 类型 key 的 field 的值</td></tr><tr><td style="text-align:center">HMGET</td><td style="text-align:center">批量获取多个 hash 类型 key 的 field 的值</td></tr><tr><td style="text-align:center">HGETALL</td><td style="text-align:center">获取一个 hash 类型的 key 中的所有的 field 和 value</td></tr><tr><td style="text-align:center">HKEYS</td><td style="text-align:center">获取一个 hash 类型的 key 中的所有的 field</td></tr><tr><td style="text-align:center">HINCRBY</td><td style="text-align:center">让一个 hash 类型 key 的字段值自增并指定步长</td></tr><tr><td style="text-align:center">HSETNX</td><td style="text-align:center">添加一个 hash 类型的 key 的 field 值，前提是这个 field 不存在，否则不执行</td></tr></tbody></table></div><h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>Redis 中的 List 类型与 Java 中的 LinkedList 类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与 LinkedList 类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p>List的常见命令有：</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">LPUSH key element …</td><td style="text-align:center">向列表左侧插入一个或多个元素</td></tr><tr><td style="text-align:center">LPOP key</td><td style="text-align:center">移除并返回列表左侧的第一个元素，没有则返回 nil</td></tr><tr><td style="text-align:center">RPUSH key element …</td><td style="text-align:center">向列表右侧插入一个或多个元素</td></tr><tr><td style="text-align:center">RPOP key</td><td style="text-align:center">移除并返回列表右侧的第一个元素</td></tr><tr><td style="text-align:center">LRANGE key start end</td><td style="text-align:center">返回一段角标范围内的所有元素</td></tr><tr><td style="text-align:center">BLPOP 和 BRPOP</td><td style="text-align:center">与 LPOP 和 RPOP 类似，只不过在没有元素时等待指定时间，而不是直接返回 nil</td></tr></tbody></table></div><h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p>Redis 的 Set 结构与 Java 中的 HashSet 类似，可以看做是一个 value 为 null 的 HashMap。因为也是一个 hash 表，因此具备与 HashSet 类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><p>Set的常见命令有：</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">SADD key member …</td><td style="text-align:center">向set中添加一个或多个元素</td></tr><tr><td style="text-align:center">SREM key member …</td><td style="text-align:center">移除set中的指定元素</td></tr><tr><td style="text-align:center">SCARD key</td><td style="text-align:center">返回set中元素的个数</td></tr><tr><td style="text-align:center">SISMEMBER key member</td><td style="text-align:center">判断一个元素是否存在于set中</td></tr><tr><td style="text-align:center">SMEMBERS</td><td style="text-align:center">获取set中的所有元素</td></tr><tr><td style="text-align:center">SINTER key1 key2 …</td><td style="text-align:center">求key1与key2的交集</td></tr><tr><td style="text-align:center">SUNION key1 key2 …</td><td style="text-align:center">求key1与key2的并集</td></tr><tr><td style="text-align:center">SDIFF key1 key2 …</td><td style="text-align:center">求key1与key2的差集</td></tr></tbody></table></div><h2 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h2><p>Redis 的 SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet 中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash 表。</p><p>SortedSet 具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><p>SortedSet的常见命令有：</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">ZADD key score member</td><td style="text-align:center">添加一个或多个元素到 sorted set ，如果已经存在则更新其score值</td></tr><tr><td style="text-align:center">ZREM key member</td><td style="text-align:center">删除 sorted set 中的一个指定元素</td></tr><tr><td style="text-align:center">ZSCORE key member</td><td style="text-align:center">获取 sorted set 中的指定元素的score值</td></tr><tr><td style="text-align:center">ZRANK key member</td><td style="text-align:center">获取 sorted set 中的指定元素的排名</td></tr><tr><td style="text-align:center">ZCARD key</td><td style="text-align:center">获取 sorted set 中的元素个数</td></tr><tr><td style="text-align:center">ZCOUNT key min max</td><td style="text-align:center">统计score值在给定范围内的所有元素的个数</td></tr><tr><td style="text-align:center">ZINCRBY key increment member</td><td style="text-align:center">让 sorted set 中的指定元素自增，步长为指定的increment值</td></tr><tr><td style="text-align:center">ZRANGE key min max</td><td style="text-align:center">按照score排序后，获取指定排名范围内的元素</td></tr><tr><td style="text-align:center">ZRANGEBYSCORE key min max</td><td style="text-align:center">按照score排序后，获取指定score范围内的元素</td></tr><tr><td style="text-align:center">ZDIFF、ZINTER、ZUNION</td><td style="text-align:center">求差集、交集、并集</td></tr></tbody></table></div><div class="note simple"><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><strong>升序</strong>获取 sorted set 中的指定元素的排名：ZRANK key member</li><li><strong>降序</strong>获取 sorted set 中的指定元素的排名：ZREVRANK key memeber</li></ul></div><h1 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h1><ul><li>在 Redis 官网中提供了各种语言的客户端，地址：<a href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></li></ul><p>其中 Java 客户端也包含很多：Redisson, Jedis, lettuce, vertx-redis-client, redis-protocol, JRedis, java-redis-client</p><p>在这里，我们学习三种最常见的 Java 客户端：</p><ul><li>Jedis 和 Lettuce：这两个主要是提供了 Redis 命令对应的 API，方便我们操作 Redis，而 SpringDataRedis 又对这两种做了抽象和封装，因此我们后期会直接以 SpringDataRedis 来学习。</li><li>Redisson：是在 Redis 基础上实现了分布式的可伸缩的 Java 数据结构，例如 Map、Queue 等，而且支持跨进程的同步机制：Lock、Semaphore 等待，比较适合用来实现特殊的功能需求。</li></ul><h2 id="Jedis客户端"><a href="#Jedis客户端" class="headerlink" title="Jedis客户端"></a>Jedis客户端</h2><p>Jedis的官网地址： <a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ol><li><p>引入依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>建立连接</p><ul><li>新建一个单元测试类，内容如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.建立连接</span></span><br><span class="line">    <span class="comment">// jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span></span><br><span class="line">    jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">    <span class="comment">// 2.设置密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.选择库</span></span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>测试</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 存入数据</span></span><br><span class="line">    jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Bernon&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 插入hash数据</span></span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>释放资源</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>Jedis 本身是<strong>线程不安全</strong>的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用 Jedis 连接池代替 Jedis 的直连方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.jedis.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringDataRedis客户端"><a href="#SpringDataRedis客户端" class="headerlink" title="SpringDataRedis客户端"></a>SpringDataRedis客户端</h2><p>SpringData 是 Spring 中数据操作的模块，包含对各种数据库的集成，其中对 Redis 的集成模块就叫做 SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了对不同 Redis 客户端的整合（Lettuce和Jedis）</li><li>提供了 RedisTemplate 统一API来操作 Redis</li><li>支持 Redis 的发布订阅模型</li><li>支持 Redis 哨兵和 Redis 集群</li><li>支持基于 Lettuce 的响应式编程</li><li>支持基于 JDK、JSON、字符串、Spring 对象的数据序列化及反序列化</li><li>支持基于 Redis 的 JDKCollection 实现</li></ul><p>SpringDataRedis 中提供了 RedisTemplate 工具类，其中封装了各种对 Redis 的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><div class="table-container"><table><thead><tr><th style="text-align:center">API</th><th style="text-align:center">返回值类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">redisTemplate.opsForValue()</td><td style="text-align:center">ValueOperations</td><td style="text-align:center">操作 String 类型数据</td></tr><tr><td style="text-align:center">redisTemplate.opsForHash()</td><td style="text-align:center">HashOperations</td><td style="text-align:center">操作 Hash 类型数据</td></tr><tr><td style="text-align:center">redisTemplate.opsForList()</td><td style="text-align:center">ListOperations</td><td style="text-align:center">操作 List 类型数据</td></tr><tr><td style="text-align:center">redisTemplate.opsForSet()</td><td style="text-align:center">SetOperations</td><td style="text-align:center">操作 Set 类型数据</td></tr><tr><td style="text-align:center">redisTemplate.opsForZSet()</td><td style="text-align:center">ZSetOperations</td><td style="text-align:center">操作 SortedSet 类型数据</td></tr><tr><td style="text-align:center">redisTemplate</td><td style="text-align:center">-</td><td style="text-align:center">执行 Redis 通用命令</td></tr></tbody></table></div><h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><p>SpringBoot 已经提供了对 SpringDataRedis 的支持，使用非常简单。</p><p>首先，新建一个 <strong>maven</strong> 项目，然后按照下面步骤执行：</p><ol><li><p>引入依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Jackson依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Lombok --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Test --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置Redis</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">    <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure></li><li><p>注入RedisTemplate</p><p> 因为有了SpringBoot的自动装配，我们可以拿来就用：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line">    <span class="comment">// 自动装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写测试</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 写入一条String数据</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Bernon&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取String数据</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><p>RedisTemplate 可以接收任意 Object 作为值写入 Redis</p><p>只不过写入前会把 Object 序列化为字节形式，默认是采用 JDK 序列化，得到的结果是这样的：</p><div class="note info no-icon flat"><p>\xAC\xED\x00\x05t\x00\x06\xE5\xBC\xA0\xE4\xB8\x89</p></div><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> </span><br><span class="line">                                        <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里采用了 JSON 序列化来代替默认的 JDK 序列化方式。最终结果如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.bernon.redis.proj.user&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Jack&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>整体可读性有了很大提升，并且能将 Java 对象自动的序列化为 JSON 字符串，并且查询时能自动把 JSON 反序列化为 Java 对象。不过，其中记录了序列化时对应的 class 名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p><h3 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h3><p>为了节省内存空间，我们可以不使用 JSON 序列化器来处理 value，而是统一使用 String 序列化器，要求只能存储 String 类型的 key 和 value。当需要存储 Java 对象时，手动完成对象的序列化和反序列化。</p><p>因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了。</p><p>这种用法比较普遍，因此 SpringDataRedis 就提供了 RedisTemplate 的子类：StringRedisTemplate，它的 key 和 value 的序列化方式默认就是 String 方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringRedisTemplate</span> <span class="keyword">extends</span> <span class="title class_">RedisTemplate</span>&lt;String, String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringRedisTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="built_in">this</span>.setValueSerializer(RedisSerializer.string());</span><br><span class="line">        <span class="built_in">this</span>.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="built_in">this</span>.setHashValueSerializer(RedisSerializer.string());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="comment">// JSON序列化工具</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Bernon&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 手动序列化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:1&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">    <span class="comment">// 手动反序列化</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二篇文章</title>
      <link href="/2026/01/23/2026-1-23-%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2026/01/23/2026-1-23-%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="The-second-note"><a href="#The-second-note" class="headerlink" title="The second note"></a>The second note</h2>]]></content>
      
      
      <categories>
          
          <category> learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[:root {  --trans-light: rgba(255, 255, 255, 0.88);  --trans-dark: rgba(25, 25, 25, 0.88);  --border-style: 1px solid rgb(169, 169, 169);  --backdrop-filter: blur(5px) saturate(150%); }/* 页脚与头图透明化 */#footer {    background: transparent !important;}#page-header {    background: transparent !important;}/* 白天模式遮罩透明 *//* #footer::before {    background: transparent !important;}#page-header::before {    background: transparent !important;} *//* 夜间模式遮罩透明 *//* [data-theme="dark"] #footer::before {    background: transparent !important;}[data-theme="dark"] #page-header::before {    background: transparent !important;} *//* 鼠标样式 */#cursor {  position: fixed;  width: 16px;  height: 16px;  /* 这里改变跟随的底色 */  background: rgb(100, 149, 237);  border-radius: 8px;  opacity: 0.25;  z-index: 10086;  pointer-events: none;  transition: 0.2s ease-in-out;  transition-property: background, opacity, transform;}#cursor.hidden {  opacity: 0;}#cursor.hover {  opacity: 0.1;  transform: scale(2.5);  -webkit-transform: scale(2.5);  -moz-transform: scale(2.5);  -ms-transform: scale(2.5);  -o-transform: scale(2.5);}#cursor.active {  opacity: 0.5;  transform: scale(0.5);  -webkit-transform: scale(0.5);  -moz-transform: scale(0.5);  -ms-transform: scale(0.5);  -o-transform: scale(0.5);}/* 首页文章卡片 */#recent-posts .recent-post-item {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 25px;  border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 18px;  border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive {  background: rgba(255, 255, 255, 0.92);  backdrop-filter: var(--backdrop-filter);  border: var(--border-style);  border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {  background: rgba(255, 255, 255, 0.75);  backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {  background: rgba(0, 0, 0, 0.7) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts .recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page {  background: var(--trans-dark);}/* 夜间模式页脚页头遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 文章页H1-H6图标样式效果 *//* 控制风车转动速度 4s那里可以自己调节快慢 */h1::before,h2::before,h3::before,h4::before,h5::before,h6::before {  -webkit-animation: ccc 4s linear infinite;  animation: ccc 4s linear infinite;}/* 控制风车转动方向 -1turn 为逆时针转动，1turn 为顺时针转动，相同数字部分记得统一修改 */@-webkit-keyframes ccc {  0% {    -webkit-transform: rotate(0deg);    transform: rotate(0deg);  }  to {    -webkit-transform: rotate(-1turn);    transform: rotate(-1turn);  }}@keyframes ccc {  0% {    -webkit-transform: rotate(0deg);    transform: rotate(0deg);  }  to {    -webkit-transform: rotate(-1turn);    transform: rotate(-1turn);  }}/* 设置风车颜色 */#content-inner.layout h1::before {  color: #2e7dd7;          /* 深海蓝，主题主色 */  font-size: 1.3rem;  margin-top: -0.23rem;}#content-inner.layout h2::before {  color: #1fbfb8;          /* 薄荷青 */  font-size: 1.1rem;  margin-top: -0.12rem;}#content-inner.layout h3::before {  color: #f2b035;          /* 琥珀金 */  font-size: 0.95rem;  margin-top: -0.09rem;}#content-inner.layout h4::before {  color: #f78c6b;          /* 珊瑚橙 */  font-size: 0.8rem;  margin-top: -0.09rem;}#content-inner.layout h5::before {  color: #ba68c8;          /* 薰衣紫 */  font-size: 0.7rem;  margin-top: 0rem;}#content-inner.layout h6::before {  color: #72bf4e;          /* 青柠绿 */  font-size: 0.66rem;  margin-top: 0rem; }#content-inner.layout h1:hover::before,#content-inner.layout h2:hover::before,#content-inner.layout h3:hover::before,#content-inner.layout h4:hover::before,#content-inner.layout h5:hover::before,#content-inner.layout h6:hover::before {  /* color: #2e7dd7;  */  -webkit-animation: ccc 6s linear infinite;  animation: ccc 6s linear infinite;}/* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 *//* .menus_items .menus_item:nth-child(2) .menus_item_child {  left: -125px;} *//* 移动端隐藏导航/菜单的社交，不影响侧栏个人卡片 */@media (max-width: 768px) {  #nav .social-icon,  #page-header .social-icon,  .menu-social {    display: none !important;  }}/* 欢迎信息 */#welcome-info {  background: linear-gradient(45deg, #b9f4f3, #e3fbf9);  border-radius: 18px;  padding: 8px;}[data-theme="dark"] #welcome-info {  background: #212121;}/* 头像状态 */.card-info-avatar .author-status-box {  position: absolute;  bottom: 0;  left: calc(100% - 28px);  width: 28px;  height: 28px;  border: 1px solid #d0d7de;  border-radius: 2em;  background-color: #f8f8f8;  transition: 0.4s;  overflow: hidden;}[data-theme="dark"] .card-info-avatar .author-status-box {  background-color: #222222;  border: 1px solid #5c6060;}.card-info-avatar .author-status {  display: flex;  align-items: center;  justify-content: flex-start; /* 靠左排列，避免偏右 */  height: 28px;  padding: 0 6px;  gap: 4px;}.card-info-avatar .author-status span:nth-child(1) {  width: 16px;               /* emoji 始终占位显示 */  flex: 0 0 16px;  text-align: center;  font-size: 16px;  line-height: 1;  transform: translate(-3px, -2px); /* 向左上微调 */}.card-info-avatar .author-status span:nth-child(2) {  width: 0;                  /* 收起时隐藏文字 */  flex: 1 1 auto;  font-size: 12px;  height: 100%;  overflow: hidden;  text-overflow: ellipsis;  white-space: nowrap;  transition: 0.4s;}.card-info-avatar .author-status-box:hover {  width: 110px;              /* 向右展开 */}.card-info-avatar .author-status-box:hover .author-status span:nth-child(2) {  width: 80px;               /* 展开时显示文字 */  margin-left: 0;}.card-widget .card-info-avatar {  display: inline-block;  position: relative;}/* 波浪css */.main-hero-waves-area {  width: 100%;  position: absolute;  left: 0;  bottom: -38px;  z-index: -1;}.waves-area .waves-svg {  width: 100%;  height: 5rem;}/* Animation */.parallax > use {  animation: move-forever 25s cubic-bezier(0.55, 0.5, 0.45, 0.5) infinite;}.parallax > use:nth-child(1) {  animation-delay: -2s;  animation-duration: 7s;  fill: rgba(58, 111, 201, 0.9);   /* 亮深蓝 */  /* fill: rgba(8, 25, 54, 0.85);  太空深蓝 */}.parallax > use:nth-child(2) {  animation-delay: -3s;  animation-duration: 10s;  fill: rgba(92, 156, 255, 0.65);  /* 亮天蓝 */  /* fill: rgba(24, 69, 140, 0.65);  星空蓝 */}.parallax > use:nth-child(3) {  animation-delay: -4s;  animation-duration: 13s;  fill: rgba(135, 207, 255, 0.55); /* 云白蓝 */  /* fill: rgba(52, 132, 210, 0.45);  曙光蓝 */}.parallax > use:nth-child(4) {  animation-delay: -5s;  animation-duration: 20s;  fill: rgba(188, 237, 255, 0.45); /* 高光蓝 */  /* fill: rgba(116, 200, 255, 0.35);  云层青 */}/* 黑色模式背景 */[data-theme="dark"] .parallax > use:nth-child(1) {  animation-delay: -2s;  animation-duration: 7s;  fill: rgba(3, 10, 24, 0.9); }[data-theme="dark"] .parallax > use:nth-child(2) {  animation-delay: -3s;  animation-duration: 10s;  fill: rgba(14, 34, 84, 0.7); }[data-theme="dark"] .parallax > use:nth-child(3) {  animation-delay: -4s;  animation-duration: 13s;  fill: rgba(32, 78, 150, 0.5);}[data-theme="dark"] .parallax > use:nth-child(4) {  animation-delay: -5s;  animation-duration: 20s;  fill: rgba(68, 140, 210, 0.35);}@keyframes move-forever {  0% {    transform: translate3d(-90px, 0, 0);  }  100% {    transform: translate3d(85px, 0, 0);  }}/*Shrinking for mobile*/@media (max-width: 768px) {  .waves-area .waves-svg {    height: 40px;    min-height: 40px;  }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) {}    return "";};class Cursor {    constructor() {        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='1.0' fill='rgb(100, 149, 237)'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover  = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout   = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove  = e => {(this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = {x: e.clientX - 8, y: e.clientY - 8}; this.cursor.classList.remove("hidden");};        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown  = e => this.cursor.classList.add("active");        document.onmouseup    = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/share.js"/>
      <url>/js/share.js</url>
      
        <content type="html"><![CDATA[function share_() {    let url = window.location.origin + window.location.pathname;    try {        // 截取标题        var title = document.title;        var subTitle = title.endsWith("| Bernon's Blog") ? title.substring(0, title.length - 14) : title;        var shareText = 'Bernon\'s Blog的站内分享\n标题：' + subTitle + '\n链接：' + url + '\n欢迎来访！🍭🍭🍭';                navigator.clipboard.writeText(shareText).then(() => {            // 使用 Hexo 内置 snackbar 通知            if (typeof btf !== 'undefined' && btf.snackbarShow) {                btf.snackbarShow("成功复制分享信息🎉");            } else {                alert("成功复制分享信息🎉");            }        }).catch(err => {            console.error('复制失败！', err);        });    } catch (err) {        console.error('分享失败！', err);    }}// 防抖函数function debounce(func, wait) {    let timeout;    return function executedFunction(...args) {        const later = () => {            clearTimeout(timeout);            func(...args);        };        clearTimeout(timeout);        timeout = setTimeout(later, wait);    };}// 执行防抖分享const share = debounce(share_, 300);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/tencentmap.js"/>
      <url>/js/tencentmap.js</url>
      
        <content type="html"><![CDATA[// 1. 声明全局变量，存储IP定位结果，避免未定义报错let ipLocation = null;// 2. 腾讯地图IP定位get请求（异步）// https://lbs.qq.com/$.ajax({    type: 'get',    url: 'https://apis.map.qq.com/ws/location/v1/ip',    dataType: 'jsonp',    jsonp: 'callback',     data: {        key: 'UKZBZ-6PILQ-36Y5P-2XIUJ-T5WZ6-Q7BSD',        output: 'jsonp'    },    success: function (res) {        console.log('IP定位成功:', res);        if (res.status === 0) {            ipLocation = res;            showWelcome();  // 成功后立即显示欢迎信息        } else {            console.error('IP定位失败:', res.message);        }    },    error: function(xhr, status, error) {        console.error('请求失败:', error);    }})function getDistance(e1, n1, e2, n2) {    const R = 6371    const { sin, cos, asin, PI, hypot } = Math    let getPoint = (e, n) => {        e *= PI / 180        n *= PI / 180        return { x: cos(n) * cos(e), y: cos(n) * sin(e), z: sin(n) }    }    let a = getPoint(e1, n1)    let b = getPoint(e2, n2)    let c = hypot(a.x - b.x, a.y - b.y, a.z - b.z)    let r = asin(c / 2) * 2 * R    return Math.round(r);}function showWelcome() {    let dist = getDistance(103.687000, 36.113000, ipLocation.result.location.lng, ipLocation.result.location.lat);     let pos = ipLocation.result.ad_info.nation;    let ip;    let posdesc;    //根据国家、省份、城市信息自定义欢迎语    switch (ipLocation.result.ad_info.nation) {           case "美国":            posdesc = "The road keeps going.";            break;        case "英国":            posdesc = "Tea is ready, take your time.";            break;        case "俄罗斯":            posdesc = "Снег ещё не растаял.";            break;        case "法国":            posdesc = "Le temps ralentit sous la lumière du soir.";            break;        case "德国":            posdesc = "Die Zeit verging im Fluge.";            break;        case "意大利":            posdesc = "Il sole cade sulle pietre antiche.";            break;        case "澳大利亚":            posdesc = "The ocean is calling.";            break;        case "加拿大":            posdesc = "Une feuille d’érable est tombée.";            break;        case "西班牙":            posdesc = "La noche apenas comienza.";            break;        case "日本":            posdesc = "風鈴が、そっと鳴った";            break;        case "韩国":            posdesc = "바람이 만나고 산해를 건너, 반갑습니다!";            break;        case "中国":            pos = ipLocation.result.ad_info.province + " " + ipLocation.result.ad_info.city + " " + ipLocation.result.ad_info.district;            ip = ipLocation.result.ip;            switch (ipLocation.result.ad_info.province) {                case "北京市":                    posdesc = "钟声未远，故事仍在继续。";                    break;                case "上海市":                    posdesc = "灯还亮着，夜色正好。";                    break;                case "天津市":                    posdesc = "海风拂过，茶香未散。";                    break;                case "重庆市":                    posdesc = "雾起山城，路向上生长。";                    break;                case "河北省":                    posdesc = "山势巍巍成壁垒，天下雄关。铁马金戈由此向，无限江山。";                    break;                case "山西省":                    posdesc = "窑火不灭，夜色很深。";                    break;                case "辽宁省":                    posdesc = "海很近，工业很重。";                    break;                case "吉林省":                    posdesc = "林深雪厚，夜很安静。";                    break;                case "黑龙江省":                    posdesc = "雪落无声，灯却很暖。";                    break;                case "江苏省":                    posdesc = "水慢慢流，话也慢慢说。";                    break;                case "浙江省":                    posdesc = "东风渐绿西湖柳，雁已还人未南归。";                    break;                case "安徽省":                    posdesc = "山影入墨，天色微淡。";                    break;                case "福建省":                    posdesc = "井邑白云间，岩城远带山。";                    break;                case "江西省":                    posdesc = "落霞与孤鹜齐飞，秋水共长天一色。";                    break;                case "山东省":                    posdesc = "风从海来，人讲分量。";                    break;                case "河南省":                    posdesc = "黄河远上白云间，一片孤城万仞山。";                    break;                case "湖北省":                    posdesc = "水面开阔，天色翻涌。";                    break;                case "湖南省":                    posdesc = "山不说话，火却很旺。";                    break;                case "广东省":                    posdesc = "早茶未凉，生活正忙。";                    break;                case "海南省":                    posdesc = "朝观日出逐白浪，夕看云起收霞光。";                    break;                case "四川省":                    posdesc = "云低下来，日子变软。";                    break;                case "贵州省":                    posdesc = "雾散得慢，酒却很快。";                    break;                case "云南省":                    posdesc = "风穿过高原，花开得自由。";                    break;                case "陕西省":                    posdesc = "城墙很厚，夜色很静。";                    break;                case "甘肃省":                    posdesc = "羌笛何须怨杨柳，春风不度玉门关。";                    break;                case "青海省":                    posdesc = "湖面如镜，世界很大。";                    break;                case "台湾省":                    posdesc = "我在这头，大陆在那头。";                    break;                case "内蒙古自治区":                    posdesc = "天苍苍，野茫茫，风吹草低见牛羊。";                    break;                case "广西壮族自治区":                    posdesc = "山在水中，水在山里。";                    break;                case "西藏自治区":                    posdesc = "天空很近，脚步很轻。";                    break;                case "宁夏回族自治区":                    posdesc = "大漠孤烟直耸，长河落日圆。";                    break;                case "新疆维吾尔自治区":                    posdesc = "驼铃古道丝绸路，胡马犹闻唐汉风。";                    break;                case "香港特别行政区":                    posdesc = "霓虹很亮，夜从不等人。";                    break;                case "澳门特别行政区":                    posdesc = "灯影摇晃，时间放慢。";                    break;                default:                    posdesc = "带我去你的城市逛逛吧！";                    break;            }            break;        default:            posdesc = "带我去你的国家逛逛吧。";            break;    }    //根据本地时间切换欢迎语    let timeChange;    let date = new Date();    if (date.getHours() >= 5 && date.getHours() < 11) timeChange = "天色渐亮，世界慢慢醒来。";    else if (date.getHours() >= 11 && date.getHours() < 13) timeChange = "阳光正好，时间不必太快。";    else if (date.getHours() >= 13 && date.getHours() < 15) timeChange = "午后很轻，思绪正散开。";    else if (date.getHours() >= 15 && date.getHours() < 16) timeChange = "时光静好，悠然自得。";    else if (date.getHours() >= 16 && date.getHours() < 19) timeChange = "黄昏在靠近，风开始变软。";    else if (date.getHours() >= 19 && date.getHours() < 24) timeChange = "夜色已深，灯还亮着。";    else timeChange = "夜深了，早点休息，少熬夜。";    try {        //自定义文本和需要放的位置        document.getElementById("welcome-info").innerHTML = `            <div style="font-weight:700;">                <div style="text-align:center;margin-bottom:6px;">                🎉 欢迎信息 🎉                </div>                欢迎来自                 <span style="color:#49b1f5;font-weight:700;">${pos}</span> 的小伙伴，                ${timeChange}                您现在距离站长约                 <span style="color:#49b1f5;font-weight:700;">${dist}</span> 公里，                ${posdesc}            </div>        `;            // `<b><center>🎉 欢迎信息 🎉</center>&emsp;&emsp;欢迎来自 <span style="color:var(--theme-color, #49b1F5)">${pos}</span> 的小伙伴，${timeChange}您现在距离站长约 <span style="color:var(--theme-color, #49b1F5)">${dist}</span> 公里， ${posdesc}</b>`;    } catch (err) {        // console.log("Pjax无法获取#welcome-info元素🙄🙄🙄")    }}// window.onload = showWelcome;// 如果使用了pjax在加上下面这行代码// document.addEventListener('pjax:complete', showWelcome);]]></content>
      
    </entry>
    
    
  
</search>
